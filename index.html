<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>실시간 추첨/호명 명단</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-slate-50 text-slate-900 min-h-screen">
  <div class="max-w-5xl mx-auto p-4 md:p-8 space-y-4">
    <header class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
      <div>
        <h1 class="text-xl md:text-2xl font-bold">실시간 추첨/호명 명단</h1>
        <p class="text-sm text-slate-600">
          PC/모바일에서 동시에 입력하면 즉시 동기화됩니다.
          <span id="sessionLabel" class="font-medium"></span>
        </p>
      </div>

      <div class="flex gap-2 items-center flex-wrap">
        <button id="resultViewBtn" class="px-3 py-2 rounded-lg bg-slate-900 text-white hover:bg-slate-800">
          결과 전체화면
        </button>
        <button id="resetBtn" class="px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700">
          전체 초기화(새 세션)
        </button>
      </div>
    </header>

    <section class="bg-white rounded-2xl shadow-sm border p-4">
      <div class="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
        <div class="md:col-span-4">
          <label class="block text-sm font-medium mb-1">이름</label>
          <input id="nameInput" class="w-full px-3 py-2 rounded-lg border" placeholder="예: 홍길동" />
        </div>
        <div class="md:col-span-4">
          <label class="block text-sm font-medium mb-1">번호</label>
          <input id="numberInput" class="w-full px-3 py-2 rounded-lg border" placeholder="예: 12 (001도 가능)" />
        </div>
        <div class="md:col-span-4 flex gap-2">
          <button id="addBtn" class="flex-1 px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700">
            명단 추가
          </button>
          <button id="quickClearBtn" class="px-3 py-2 rounded-lg border hover:bg-slate-50">
            입력칸 비우기
          </button>
        </div>
      </div>

      <p id="status" class="text-sm text-slate-600 mt-3"></p>
    </section>

    <main class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <section class="bg-white rounded-2xl shadow-sm border overflow-hidden">
        <div class="p-4 border-b flex items-center justify-between">
          <h2 class="font-bold">대기 명단</h2>
          <span id="pendingCount" class="text-sm text-slate-600"></span>
        </div>
        <div class="max-h-[60vh] overflow-auto">
          <table class="w-full text-sm">
            <thead class="sticky top-0 bg-slate-100">
              <tr>
                <th class="text-left p-2 w-16">순번</th>

                <!-- ✅ 정렬 클릭 가능 -->
                <th class="text-left p-2">
                  <button id="sortNameBtn" class="inline-flex items-center gap-1 font-semibold hover:underline">
                    이름 <span id="sortNameIcon" class="text-slate-500"></span>
                  </button>
                </th>

                <th class="text-left p-2 w-28">
                  <button id="sortNumberBtn" class="inline-flex items-center gap-1 font-semibold hover:underline">
                    번호 <span id="sortNumberIcon" class="text-slate-500"></span>
                  </button>
                </th>

                <th class="text-left p-2 w-28">호명</th>
              </tr>
            </thead>
            <tbody id="pendingTbody"></tbody>
          </table>
        </div>
      </section>

      <section class="bg-white rounded-2xl shadow-sm border overflow-hidden">
        <div class="p-4 border-b flex items-center justify-between">
          <h2 class="font-bold">완료 명단</h2>
          <span id="doneCount" class="text-sm text-slate-600"></span>
        </div>
        <div class="max-h-[60vh] overflow-auto">
          <table class="w-full text-sm">
            <thead class="sticky top-0 bg-slate-100">
              <tr>
                <th class="text-left p-2 w-16">순번</th>

                <!-- 완료도 같은 정렬 적용 -->
                <th class="text-left p-2">이름</th>
                <th class="text-left p-2 w-28">번호</th>

                <th class="text-left p-2 w-28">취소</th>
              </tr>
            </thead>
            <tbody id="doneTbody"></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <!-- ✅ 결과 전체화면 오버레이 (이름/번호만 크게) -->
  <div id="resultOverlay" class="fixed inset-0 bg-black/90 text-white hidden z-50">
    <div class="h-full flex flex-col">
      <div class="p-3 md:p-4 flex items-center justify-between border-b border-white/10">
        <div class="text-sm md:text-base opacity-90">
          결과 화면 · 실시간 연동
          <span id="resultSessionLabel" class="ml-2 font-semibold"></span>
        </div>
        <div class="flex gap-2">
          <button id="resultSortNameBtn" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20">
            이름 정렬
          </button>
          <button id="resultSortNumberBtn" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20">
            번호 정렬
          </button>
          <button id="exitResultBtn" class="px-3 py-2 rounded-lg bg-rose-500 hover:bg-rose-600">
            닫기
          </button>
        </div>
      </div>

      <div class="flex-1 overflow-auto p-3 md:p-6">
        <!-- 모바일: 1열 / PC: 2~3열 -->
        <div id="resultGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 md:gap-4"></div>
      </div>

      <div class="p-3 md:p-4 text-xs md:text-sm opacity-80 border-t border-white/10">
        팁: 이름/번호 정렬 버튼을 누르면 오름↔내림 토글됩니다.
      </div>
    </div>
  </div>

  <script type="module">
    // ===== Firebase SDK (모듈) =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, serverTimestamp,
      collection, addDoc, onSnapshot, query, orderBy, updateDoc
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // 1) Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDEsSa0HwIZ44HWez0oOTtuNRvnX_eVU9U",
      authDomain: "pick-gift.firebaseapp.com",
      projectId: "pick-gift",
      storageBucket: "pick-gift.firebasestorage.app",
      messagingSenderId: "372503045664",
      appId: "1:372503045664:web:b6d31074c9dee9a6dffe45",
      measurementId: "G-Y5N46XNLH2"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ===== UI =====
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");
    const sessionLabelEl = $("sessionLabel");

    const pendingTbody = $("pendingTbody");
    const doneTbody = $("doneTbody");
    const pendingCountEl = $("pendingCount");
    const doneCountEl = $("doneCount");

    const sortNameBtn = $("sortNameBtn");
    const sortNumberBtn = $("sortNumberBtn");
    const sortNameIcon = $("sortNameIcon");
    const sortNumberIcon = $("sortNumberIcon");

    // Result overlay UI
    const resultOverlay = $("resultOverlay");
    const resultViewBtn = $("resultViewBtn");
    const exitResultBtn = $("exitResultBtn");
    const resultGrid = $("resultGrid");
    const resultSessionLabel = $("resultSessionLabel");
    const resultSortNameBtn = $("resultSortNameBtn");
    const resultSortNumberBtn = $("resultSortNumberBtn");

    function setStatus(msg) { statusEl.textContent = msg || ""; }

    function safeText(s) {
      return (s ?? "").toString().replace(/[<>&"]/g, (c) => ({
        "<":"&lt;", ">":"&gt;", "&":"&amp;", '"':"&quot;"
      }[c]));
    }

    // ✅ 번호 정규화: "001" -> "1", "01" -> "1"
    function normalizeNumber(num) {
      const t = String(num ?? "").trim();
      if (t === "") return "";
      const n = Number(t);
      if (Number.isNaN(n)) return t;
      return String(Math.trunc(n));
    }

    function nameKey(name) {
      return String(name ?? "").trim().toLocaleLowerCase("ko");
    }
    function numberKey(num) {
      const n = Number(normalizeNumber(num));
      return Number.isNaN(n) ? Infinity : n;
    }

    // ===== 정렬 상태 =====
    // sortBy: "created" | "name" | "number"
    // sortDir: "asc" | "desc"
    const sortState = { sortBy: "created", sortDir: "asc" };

    function setSort(by) {
      if (sortState.sortBy === by) {
        sortState.sortDir = (sortState.sortDir === "asc") ? "desc" : "asc";
      } else {
        sortState.sortBy = by;
        sortState.sortDir = "asc";
      }
      updateSortIcons();
      // render는 onSnapshot에서 불리니까 cachedEntries로 다시 그리기
      renderTableRows(cachedEntries);
      renderResultView(cachedEntries);
    }

    function updateSortIcons() {
      // 표 아이콘 표시 (name/number만)
      sortNameIcon.textContent = "";
      sortNumberIcon.textContent = "";
      if (sortState.sortBy === "name") sortNameIcon.textContent = (sortState.sortDir === "asc" ? "▲" : "▼");
      if (sortState.sortBy === "number") sortNumberIcon.textContent = (sortState.sortDir === "asc" ? "▲" : "▼");
    }

    function compareEntries(a, b) {
      const dir = (sortState.sortDir === "asc") ? 1 : -1;

      if (sortState.sortBy === "name") {
        const aa = nameKey(a.name);
        const bb = nameKey(b.name);
        if (aa < bb) return -1 * dir;
        if (aa > bb) return  1 * dir;
        // tie-breaker
        return (numberKey(a.number) - numberKey(b.number)) * dir;
      }

      if (sortState.sortBy === "number") {
        const aa = numberKey(a.number);
        const bb = numberKey(b.number);
        if (aa !== bb) return (aa - bb) * dir;
        // tie-breaker
        const na = nameKey(a.name);
        const nb = nameKey(b.name);
        if (na < nb) return -1 * dir;
        if (na > nb) return  1 * dir;
        return 0;
      }

      // 기본: createdAt 오름차순(입력 순서 유지)
      const ta = a.createdAt?.seconds ?? 0;
      const tb = b.createdAt?.seconds ?? 0;
      if (ta !== tb) return (ta - tb);
      return 0;
    }

    // ===== 데이터 구조 =====
    // app/state : { currentSessionId, updatedAt }
    // sessions/{sessionId} : { createdAt }
    // sessions/{sessionId}/entries/{entryId} : { name, number, called, createdAt, calledAt }

    const stateRef = doc(db, "app", "state");
    let currentSessionId = null;
    let unsubscribeEntries = null;

    // ✅ 실시간으로 불러온 entries 캐시 (중복 체크용 + 정렬 재렌더용)
    let cachedEntries = [];

    async function ensureState() {
      const snap = await getDoc(stateRef);
      if (!snap.exists() || !snap.data()?.currentSessionId) {
        const newId = crypto.randomUUID();
        await setDoc(doc(db, "sessions", newId), { createdAt: serverTimestamp() });
        await setDoc(stateRef, { currentSessionId: newId, updatedAt: serverTimestamp() });
      }
    }

    function renderTableRows(entries) {
      const pending = [];
      const done = [];
      entries.forEach(e => (e.called ? done : pending).push(e));

      // ✅ 정렬 적용 (각 리스트에 적용)
      const pendingSorted = pending.slice().sort(compareEntries);
      const doneSorted = done.slice().sort(compareEntries);

      pendingTbody.innerHTML = pendingSorted.map((e, idx) => `
        <tr class="border-b last:border-b-0">
          <td class="p-2 text-slate-500">${idx + 1}</td>
          <td class="p-2 font-medium">${safeText(e.name)}</td>
          <td class="p-2">${safeText(e.number)}</td>
          <td class="p-2">
            <button data-id="${e.id}" class="callBtn px-2 py-1 rounded-md bg-emerald-600 text-white hover:bg-emerald-700">
              완료
            </button>
          </td>
        </tr>
      `).join("");

      doneTbody.innerHTML = doneSorted.map((e, idx) => `
        <tr class="border-b last:border-b-0 opacity-90">
          <td class="p-2 text-slate-500">${idx + 1}</td>
          <td class="p-2 font-medium line-through">${safeText(e.name)}</td>
          <td class="p-2 line-through">${safeText(e.number)}</td>
          <td class="p-2">
            <button data-id="${e.id}" class="undoBtn px-2 py-1 rounded-md border hover:bg-slate-50">
              되돌리기
            </button>
          </td>
        </tr>
      `).join("");

      pendingCountEl.textContent = `총 ${pending.length}명`;
      doneCountEl.textContent = `총 ${done.length}명`;

      wireRowButtons();
    }

    function renderResultView(entries) {
      if (resultOverlay.classList.contains("hidden")) return;

      const pendingOnly = entries.filter(e => !e.called);
      const sorted = pendingOnly.slice().sort(compareEntries);

      // ✅ 전체화면에서는 “이름/번호만” 아주 크게
      resultGrid.innerHTML = sorted.map((e) => `
        <div class="rounded-2xl bg-white/10 border border-white/10 p-4 md:p-5">
          <div class="text-2xl md:text-4xl font-extrabold tracking-tight">
            ${safeText(e.name)}
          </div>
          <div class="mt-2 text-xl md:text-3xl font-bold opacity-90">
            ${safeText(e.number)}
          </div>
        </div>
      `).join("");
    }

    function wireRowButtons() {
      pendingTbody.querySelectorAll(".callBtn").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.dataset.id;
          await updateDoc(doc(db, "sessions", currentSessionId, "entries", id), {
            called: true,
            calledAt: serverTimestamp()
          });
        });
      });
      doneTbody.querySelectorAll(".undoBtn").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.dataset.id;
          await updateDoc(doc(db, "sessions", currentSessionId, "entries", id), {
            called: false,
            calledAt: null
          });
        });
      });
    }

    function subscribeEntries(sessionId) {
      if (unsubscribeEntries) unsubscribeEntries();

      const entriesRef = collection(db, "sessions", sessionId, "entries");
      const q = query(entriesRef, orderBy("createdAt", "asc"));

      unsubscribeEntries = onSnapshot(q, (snap) => {
        const entries = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        cachedEntries = entries;

        renderTableRows(entries);
        renderResultView(entries);

        setStatus(`연결됨 · 세션 ${sessionId.slice(0, 8)} · ${new Date().toLocaleString()}`);
      }, (err) => {
        console.error(err);
        setStatus("오류: Firestore 연결 실패. 규칙/권한/네트워크를 확인하세요.");
      });
    }

    async function createNewSessionAndSwitch() {
      const newId = crypto.randomUUID();
      await setDoc(doc(db, "sessions", newId), { createdAt: serverTimestamp() });
      await setDoc(stateRef, { currentSessionId: newId, updatedAt: serverTimestamp() }, { merge: true });
    }

    // ===== 이벤트 =====
    $("addBtn").addEventListener("click", async () => {
      const name = $("nameInput").value.trim();
      const rawNumber = $("numberInput").value.trim();

      if (!name || !rawNumber) {
        alert("이름/번호를 입력해 주세요.");
        return;
      }

      const number = normalizeNumber(rawNumber);

      // ✅ (이름 + 정규화번호) 중복 체크
      const isDuplicate = cachedEntries.some(e =>
        (e.name ?? "").trim() === name &&
        normalizeNumber(e.number) === number
      );

      if (isDuplicate) {
        alert("이미 입력되었습니다.");
        return;
      }

      const entriesRef = collection(db, "sessions", currentSessionId, "entries");
      await addDoc(entriesRef, {
        name,
        number,
        called: false,
        createdAt: serverTimestamp(),
        calledAt: null,
      });

      $("nameInput").value = "";
      $("numberInput").value = "";
      $("nameInput").focus();
    });

    $("quickClearBtn").addEventListener("click", () => {
      $("nameInput").value = "";
      $("numberInput").value = "";
      $("nameInput").focus();
    });

    $("resetBtn").addEventListener("click", async () => {
      const ok = confirm("정말 '전체 초기화(새 세션)' 할까요?\n(기존 데이터는 삭제되지 않고, 새 명단으로 전환됩니다.)");
      if (!ok) return;
      await createNewSessionAndSwitch();
    });

    // ✅ 정렬 버튼(표)
    sortNameBtn.addEventListener("click", () => setSort("name"));
    sortNumberBtn.addEventListener("click", () => setSort("number"));

    // ✅ 결과 전체화면 버튼
    resultViewBtn.addEventListener("click", async () => {
      // 전체화면 요청(모바일 포함)
      const el = resultOverlay;
      el.classList.remove("hidden");

      // 세션 라벨 표시
      resultSessionLabel.textContent = currentSessionId ? `· ${currentSessionId.slice(0, 8)}` : "";

      // 가능한 경우: 전체화면 모드 진입
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
      } catch (_) { /* 모바일/브라우저에 따라 실패 가능 */ }

      renderResultView(cachedEntries);
    });

    // ✅ 결과 화면 정렬 버튼(오버레이)
    resultSortNameBtn.addEventListener("click", () => setSort("name"));
    resultSortNumberBtn.addEventListener("click", () => setSort("number"));

    // ✅ 닫기
    exitResultBtn.addEventListener("click", async () => {
      resultOverlay.classList.add("hidden");
      try {
        if (document.fullscreenElement) await document.exitFullscreen();
      } catch (_) {}
    });

    // ESC로 닫기(PC)
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !resultOverlay.classList.contains("hidden")) {
        exitResultBtn.click();
      }
    });

    // ===== 시작 =====
    setStatus("로그인/연결 중...");
    await signInAnonymously(auth);
    await ensureState();

    // state 문서를 실시간으로 구독
    onSnapshot(stateRef, (snap) => {
      const data = snap.data();
      if (!data?.currentSessionId) return;

      const nextSessionId = data.currentSessionId;
      if (nextSessionId !== currentSessionId) {
        currentSessionId = nextSessionId;
        sessionLabelEl.textContent = `· 현재 세션: ${currentSessionId.slice(0, 8)}`;
        resultSessionLabel.textContent = `· ${currentSessionId.slice(0, 8)}`;
        subscribeEntries(currentSessionId);
      }
    });

    // 초기 아이콘 세팅
    updateSortIcons();
  </script>
</body>
</html>
